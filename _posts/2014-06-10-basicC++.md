---
layout: post
title:  "C++基础笔记"
date:   2014-06-10 12:00:00
categories: C++
permalink: /archivers/basicC++
---

# 基础知识

C++语法要求`main`函数以`int main()`开始（参数可选），如果编译器到达`main`函数的末尾没有遇到`return`语句，则默认为`return 0`。

控制符`endl`和换行符`\n`：`endl`确保程序继续运行前刷新输出——将其立即显示在屏幕上，`\n`不会。

函数原型语句：`double sqrt(double);`，类似这种格式。
C++编译器在编译代码时，需要知道函数的基本信息。
实现方法：在源代码中输入函数原型；包含头文件（其中定义了原型，函数定义包含在库文件中）。

## 数据类型

### 基本类型

整型：**char**、short、int、long、long long，每种类型都包含有符号和无符号。

sizeof运算符：

```c
sizeof(int);     //对类型名使用
sizeof a;        //a 是变量名
```

数值溢出：变量取值将为范围的另外一端的取值。

char类型：字符和小整数（实际上是一个小整数，因此可以对其进行数值运算）

```c
char ch = 77;         //与 char ch = 'M'；的效果一样
cout<<ch;            //ch中保持的值是77，**cin和cout的行为是由变量类型引导的**
result:M
```

>几个常用的字符ASCII码：
A-65    a-97    空格-32    0-48

浮点型：float、double、long double
程序把浮点常量默认保存为double，如果想保存为float，需要加`f/F`后缀，long double加`l/L`。

除法分支与运算符重载：C++根据操作数的类型来确定除法运算符的含义——如果两个操作数都是整型，将执行整型除法，结果中的小数被去掉；如果有一个数为浮点数，那么结果就是浮点数。

### 复合类型

#### 数组
初始化规则：
1. 只有在定义数组时才能使用初始化；不能讲一个数组赋给另一个数组；
2. 初始化数组时，提供的值可以少于数组的元素数目，编译器会将其他元素初始化为0；
3. 如果初始化数组时[]内为空，编译器会计算元素个数。

字符串类string的几个方法：

```c
strcpy(charr1,charr2);     //copy charr2 to charr1
strcat(charr1,charr2);     //append charr2 to charr1
strlen(charr);             //obtain length of charr（空字符不计入其中）
```

#### 结构
声明示例：

```c
struct inflatable
{
  char name[20];
  float volume;
  double price;        
}
```

初始化：

```c
inflatable temp =
{
    "Gloria",
    1.22,
    3.11
}
```

>共同体union：能够存储不同的数据类型，但只能同时存储其中的一种类型。共同体的长度是其最大成员的长度。其声明方式与结构体一样。

```c
//匿名共同体的声明：
struct widget
{
    char brand [20];
    int type;
    union
    {
        long id_num;
        char id_char[20];
    }
}
```

#### 枚举

```c
enum spectrum {red, orange, yellow, green};
```

上述语句的工作：
1. 声明了一个枚举类型spectrum；
2. 将red, orange等作为**符号常量**，他们对应整数值0-3，这些常量叫作**枚举量**，在默认情况下，将整数值赋给枚举量。

#### 指针

C++在创建指针时，计算机只分配用来存储地址的内存，不会分配用来存储指针所指向的数据的内存。

```c
long * fellow;    //声明了一个指针，但是没有将地址赋给fellow
* fellow = 2333;    //fellow没有被初始化，其可能是任何值；无论其值是什么，程序都将其解释为存储2333的地址。
//如果fellow的值为1000，而1000这个地址保存的是有效的程序数据，现在将其修改为2333，就导致了错误。

long temp = 99999;
long * p = &temp;        //将指针的值初始化为变量的地址，变量是在编译时分配的**有名称的内存**

int * p = new int;        //在运行阶段分配**未命名**的内存，存储int值
```

delete释放内存：使用new分配的内存，不会删除指针本身。

new创建动态数组：
静态联编：在编译时给数组分配内存
动态联编：在运行过程中，如果需要数组，就创建；不需要就不创建；还可以选择数组的长度。使用动态联编创建的数组叫动态数组。

```c
int * p = new int [10];        //new运算符返回第一个元素的地址
delete [] p;        //释放动态数组的内存
```

使用动态数组：

```c
int * a = new int [3];
//数组式访问
a[0] = 1;
a[1] = 2;
//指针式访问
cout<<*a;        // 1
a = a + 1;
cout<<*a;        // 2
```


指针式访问只能用于数组指针，不能对数组名使用这种方法。
>指针算术的基本原理：将整数变量+1后，其值+1；将指针变量+1后，增加的量等于**其指向的类型的字节数**。例如：对double类型指针+1，系统使用8个字节存储double，那么增加的量就是8.
注：C++将数组名解释为地址。

数组名和数组指针的区别：
1. 可以修改指针的值，数组名为常量，不能修改；
2. 对数组应用sizeof运算符得到的是数组的长度，对指针应用sizeof得到的是指针的长度。

数组的地址：数组名被解释为第一个元素的地址；对数组名应用 & 得到的是整个数组的地址。

```c
short tell[10];
cout<<tell<<endl;
cout<<&tell<<endl;
```

两次输出的结果一样，但是意义不同：tell实际是&tell[0]，是一个2个字节的内存块的地址。&tell是一个20个字节的内存块的地址。tell+1实际增加了2，&tell+1，实际增加了20（&tell指向包含10个元素的short数组，声明这种指针的方式：short (*p)[10] = &tell;）

指针与字符串：在cout和多数C++表达式中，char数组，char指针，**引号括起的字符串常量**都被解释为字符串的第一个字符的地址。
