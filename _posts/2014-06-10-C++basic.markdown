---
layout:     post
title:      "C++基础笔记"
subtitle:   "包含C++的基本数据类型、结构等！"
date:       2014-06-10 12:00:00
author:     "Anytimekaka"
header-img: "img/post-bg-01.jpg"
---

#基础知识

C++语法要求`main`函数以`int main()`开始（参数可选），如果编译器到达`main`函数的末尾没有遇到`return`语句，则默认为`return 0`。

控制符`endl`和换行符`\n`：`endl`确保程序继续运行前刷新输出——将其立即显示在屏幕上，`\n`不会。

函数原型语句：`double sqrt(double);`，类似这种格式。
C++编译器在编译代码时，需要知道函数的基本信息。
实现方法：在源代码中输入函数原型；包含头文件（其中定义了原型，函数定义包含在库文件中）。

##数据类型

###基本类型

整型：**char**、short、int、long、long long，每种类型都包含有符号和无符号。

sizeof运算符：

    sizeof(int);     //对类型名使用
    sizeof a;         //a 是变量名

数值溢出：变量取值将为范围的另外一端的取值。

char类型：字符和小整数（实际上是一个小整数，因此可以对其进行数值运算）

    char ch = 77;         //与 char ch = 'M'；的效果一样
    cout<<ch;            //ch中保持的值是77，**cin和cout的行为是由变量类型引导的**
    
    result:M

>几个常用的字符ASCII码：
A-65    a-97    空格-32    0-48

浮点型：float、double、long double
程序把浮点常量默认保存为double，如果想保存为float，需要加`f/F`后缀，long double加`l/L`。

除法分支与运算符重载：C++根据操作数的类型来确定除法运算符的含义——如果两个操作数都是整型，将执行整型除法，结果中的小数被去掉；如果有一个数为浮点数，那么结果就是浮点数。

###复合类型

####数组
初始化规则：
1. 只有在定义数组时才能使用初始化；不能讲一个数组赋给另一个数组；
2. 初始化数组时，提供的值可以少于数组的元素数目，编译器会将其他元素初始化为0；
3. 如果初始化数组时[]内为空，编译器会计算元素个数。

字符串类string的几个方法：
    
    strcpy(charr1,charr2);     //copy charr2 to charr1 
    strcat(charr1,charr2);     //append charr2 to charr1
    strlen(charr);                  //obtain length of charr（空字符不计入其中）

####结构
声明示例：

    struct inflatable
    {
        char name[20];
        float volume;
        double price;        
    }

初始化：

    inflatable temp = 
    {
        "Gloria",
        1.22,
        3.11
    }

>共同体union：能够存储不同的数据类型，但只能同时存储其中的一种类型。共同体的长度是其最大成员的长度。其声明方式与结构体一样。

    //匿名共同体的声明：
    
    struct widget
    {
        char brand [20];
        int type;
        union
        {
            long id_num;
            char id_char[20];
        }
    }

####枚举

    enum spectrum {red, orange, yellow, green};

上述语句的工作：
1. 声明了一个枚举类型spectrum；
2. 将red, orange等作为**符号常量**，他们对应整数值0-3，这些常量叫作**枚举量**，在默认情况下，将整数值赋给枚举量。

####指针

C++在创建指针时，计算机只分配用来存储地址的内存，不会分配用来存储指针所指向的数据的内存。

    long * fellow;    //声明了一个指针，但是没有将地址赋给fellow
    * fellow = 2333;    //fellow没有被初始化，其可能是任何值；无论其值是什么，程序都将其解释为存储2333的地址。
    //如果fellow的值为1000，而1000这个地址保存的是有效的程序数据，现在将其修改为2333，就导致了错误。

    long temp = 99999;
    long * p = &temp;        //将指针的值初始化为变量的地址，变量是在编译时分配的**有名称的内存**
    
    int * p = new int;        //在运行阶段分配**未命名**的内存，存储int值

delete释放内存：使用new分配的内存，不会删除指针本身。

new创建动态数组：
静态联编：在编译时给数组分配内存
动态联编：在运行过程中，如果需要数组，就创建；不需要就不创建；还可以选择数组的长度。使用动态联编创建的数组叫动态数组。

    int * p = new int [10];        //new运算符返回第一个元素的地址
    delete [] p;        //释放动态数组的内存

使用动态数组：

    int * a = new int [3];
    //数组式访问
    a[0] = 1;
    a[1] = 2;
    //指针式访问
    cout<<*a;        // 1
    a = a + 1;
    cout<<*a;        // 2

指针式访问只能用于数组指针，不能对数组名使用这种方法。
>指针算术的基本原理：将整数变量+1后，其值+1；将指针变量+1后，增加的量等于**其指向的类型的字节数**。例如：对double类型指针+1，系统使用8个字节存储double，那么增加的量就是8.
注：C++将数组名解释为地址。

数组名和数组指针的区别：
1. 可以修改指针的值，数组名为常量，不能修改；
2. 对数组应用sizeof运算符得到的是数组的长度，对指针应用sizeof得到的是指针的长度。

数组的地址：数组名被解释为第一个元素的地址；对数组名应用 & 得到的是整个数组的地址。

    short tell[10];
    cout<<tell<<endl;
    cout<<&tell<<endl;

两次输出的结果一样，但是意义不同：tell实际是&tell[0]，是一个2个字节的内存块的地址。&tell是一个20个字节的内存块的地址。tell+1实际增加了2，&tell+1，实际增加了20（&tell指向包含10个元素的short数组，声明这种指针的方式：short (*p)[10] = &tell;）

指针与字符串：在cout和多数C++表达式中，char数组，char指针，**引号括起的字符串常量**都被解释为字符串的第一个字符的地址。
































